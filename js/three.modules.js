class Matrix4{constructor(){Matrix4.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}set(t,s,i,e,r,h,n,a,o,l,c,u,x,m,y,z){const _=this.elements;return _[0]=t,_[4]=s,_[8]=i,_[12]=e,_[1]=r,_[5]=h,_[9]=n,_[13]=a,_[2]=o,_[6]=l,_[10]=c,_[14]=u,_[3]=x,_[7]=m,_[11]=y,_[15]=z,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new Matrix4).fromArray(this.elements)}copy(t){const s=this.elements,i=t.elements;return s[0]=i[0],s[1]=i[1],s[2]=i[2],s[3]=i[3],s[4]=i[4],s[5]=i[5],s[6]=i[6],s[7]=i[7],s[8]=i[8],s[9]=i[9],s[10]=i[10],s[11]=i[11],s[12]=i[12],s[13]=i[13],s[14]=i[14],s[15]=i[15],this}copyPosition(t){const s=this.elements,i=t.elements;return s[12]=i[12],s[13]=i[13],s[14]=i[14],this}setFromMatrix3(t){const s=t.elements;return this.set(s[0],s[3],s[6],0,s[1],s[4],s[7],0,s[2],s[5],s[8],0,0,0,0,1),this}extractBasis(t,s,i){return t.setFromMatrixColumn(this,0),s.setFromMatrixColumn(this,1),i.setFromMatrixColumn(this,2),this}makeBasis(t,s,i){return this.set(t.x,s.x,i.x,0,t.y,s.y,i.y,0,t.z,s.z,i.z,0,0,0,0,1),this}extractRotation(t){const s=this.elements,i=t.elements,e=1/_v1$5.setFromMatrixColumn(t,0).length(),r=1/_v1$5.setFromMatrixColumn(t,1).length(),h=1/_v1$5.setFromMatrixColumn(t,2).length();return s[0]=i[0]*e,s[1]=i[1]*e,s[2]=i[2]*e,s[3]=0,s[4]=i[4]*r,s[5]=i[5]*r,s[6]=i[6]*r,s[7]=0,s[8]=i[8]*h,s[9]=i[9]*h,s[10]=i[10]*h,s[11]=0,s[12]=0,s[13]=0,s[14]=0,s[15]=1,this}makeRotationFromEuler(t){const s=this.elements,i=t.x,e=t.y,r=t.z,h=Math.cos(i),n=Math.sin(i),a=Math.cos(e),o=Math.sin(e),l=Math.cos(r),c=Math.sin(r);if("XYZ"===t.order){const t=h*l,i=h*c,e=n*l,r=n*c;s[0]=a*l,s[4]=-a*c,s[8]=o,s[1]=i+e*o,s[5]=t-r*o,s[9]=-n*a,s[2]=r-t*o,s[6]=e+i*o,s[10]=h*a}else if("YXZ"===t.order){const t=a*l,i=a*c,e=o*l,r=o*c;s[0]=t+r*n,s[4]=e*n-i,s[8]=h*o,s[1]=h*c,s[5]=h*l,s[9]=-n,s[2]=i*n-e,s[6]=r+t*n,s[10]=h*a}else if("ZXY"===t.order){const t=a*l,i=a*c,e=o*l,r=o*c;s[0]=t-r*n,s[4]=-h*c,s[8]=e+i*n,s[1]=i+e*n,s[5]=h*l,s[9]=r-t*n,s[2]=-h*o,s[6]=n,s[10]=h*a}else if("ZYX"===t.order){const t=h*l,i=h*c,e=n*l,r=n*c;s[0]=a*l,s[4]=e*o-i,s[8]=t*o+r,s[1]=a*c,s[5]=r*o+t,s[9]=i*o-e,s[2]=-o,s[6]=n*a,s[10]=h*a}else if("YZX"===t.order){const t=h*a,i=h*o,e=n*a,r=n*o;s[0]=a*l,s[4]=r-t*c,s[8]=e*c+i,s[1]=c,s[5]=h*l,s[9]=-n*l,s[2]=-o*l,s[6]=i*c+e,s[10]=t-r*c}else if("XZY"===t.order){const t=h*a,i=h*o,e=n*a,r=n*o;s[0]=a*l,s[4]=-c,s[8]=o*l,s[1]=t*c+r,s[5]=h*l,s[9]=i*c-e,s[2]=e*c-i,s[6]=n*l,s[10]=r*c+t}return s[3]=0,s[7]=0,s[11]=0,s[12]=0,s[13]=0,s[14]=0,s[15]=1,this}makeRotationFromQuaternion(t){return this.compose(_zero,t,_one)}lookAt(t,s,i){const e=this.elements;return _z.subVectors(t,s),0===_z.lengthSq()&&(_z.z=1),_z.normalize(),_x.crossVectors(i,_z),0===_x.lengthSq()&&(1===Math.abs(i.z)?_z.x+=1e-4:_z.z+=1e-4,_z.normalize(),_x.crossVectors(i,_z)),_x.normalize(),_y.crossVectors(_z,_x),e[0]=_x.x,e[4]=_y.x,e[8]=_z.x,e[1]=_x.y,e[5]=_y.y,e[9]=_z.y,e[2]=_x.z,e[6]=_y.z,e[10]=_z.z,this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,s){const i=t.elements,e=s.elements,r=this.elements,h=i[0],n=i[4],a=i[8],o=i[12],l=i[1],c=i[5],u=i[9],x=i[13],m=i[2],y=i[6],z=i[10],_=i[14],M=i[3],d=i[7],p=i[11],g=i[15],f=e[0],b=e[4],C=e[8],v=e[12],F=e[1],k=e[5],S=e[9],$=e[13],E=e[2],V=e[6],q=e[10],w=e[14],A=e[3],Z=e[7],X=e[11],Y=e[15];return r[0]=h*f+n*F+a*E+o*A,r[4]=h*b+n*k+a*V+o*Z,r[8]=h*C+n*S+a*q+o*X,r[12]=h*v+n*$+a*w+o*Y,r[1]=l*f+c*F+u*E+x*A,r[5]=l*b+c*k+u*V+x*Z,r[9]=l*C+c*S+u*q+x*X,r[13]=l*v+c*$+u*w+x*Y,r[2]=m*f+y*F+z*E+_*A,r[6]=m*b+y*k+z*V+_*Z,r[10]=m*C+y*S+z*q+_*X,r[14]=m*v+y*$+z*w+_*Y,r[3]=M*f+d*F+p*E+g*A,r[7]=M*b+d*k+p*V+g*Z,r[11]=M*C+d*S+p*q+g*X,r[15]=M*v+d*$+p*w+g*Y,this}multiplyScalar(t){const s=this.elements;return s[0]*=t,s[4]*=t,s[8]*=t,s[12]*=t,s[1]*=t,s[5]*=t,s[9]*=t,s[13]*=t,s[2]*=t,s[6]*=t,s[10]*=t,s[14]*=t,s[3]*=t,s[7]*=t,s[11]*=t,s[15]*=t,this}determinant(){const t=this.elements,s=t[0],i=t[4],e=t[8],r=t[12],h=t[1],n=t[5],a=t[9],o=t[13],l=t[2],c=t[6],u=t[10],x=t[14];return t[3]*(+r*a*c-e*o*c-r*n*u+i*o*u+e*n*x-i*a*x)+t[7]*(+s*a*x-s*o*u+r*h*u-e*h*x+e*o*l-r*a*l)+t[11]*(+s*o*c-s*n*x-r*h*c+i*h*x+r*n*l-i*o*l)+t[15]*(-e*n*l-s*a*c+s*n*u+e*h*c-i*h*u+i*a*l)}transpose(){const t=this.elements;let s;return s=t[1],t[1]=t[4],t[4]=s,s=t[2],t[2]=t[8],t[8]=s,s=t[6],t[6]=t[9],t[9]=s,s=t[3],t[3]=t[12],t[12]=s,s=t[7],t[7]=t[13],t[13]=s,s=t[11],t[11]=t[14],t[14]=s,this}setPosition(t,s,i){const e=this.elements;return t.isVector3?(e[12]=t.x,e[13]=t.y,e[14]=t.z):(e[12]=t,e[13]=s,e[14]=i),this}invert(){const t=this.elements,s=t[0],i=t[1],e=t[2],r=t[3],h=t[4],n=t[5],a=t[6],o=t[7],l=t[8],c=t[9],u=t[10],x=t[11],m=t[12],y=t[13],z=t[14],_=t[15],M=c*z*o-y*u*o+y*a*x-n*z*x-c*a*_+n*u*_,d=m*u*o-l*z*o-m*a*x+h*z*x+l*a*_-h*u*_,p=l*y*o-m*c*o+m*n*x-h*y*x-l*n*_+h*c*_,g=m*c*a-l*y*a-m*n*u+h*y*u+l*n*z-h*c*z,f=s*M+i*d+e*p+r*g;if(0===f)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const b=1/f;return t[0]=M*b,t[1]=(y*u*r-c*z*r-y*e*x+i*z*x+c*e*_-i*u*_)*b,t[2]=(n*z*r-y*a*r+y*e*o-i*z*o-n*e*_+i*a*_)*b,t[3]=(c*a*r-n*u*r-c*e*o+i*u*o+n*e*x-i*a*x)*b,t[4]=d*b,t[5]=(l*z*r-m*u*r+m*e*x-s*z*x-l*e*_+s*u*_)*b,t[6]=(m*a*r-h*z*r-m*e*o+s*z*o+h*e*_-s*a*_)*b,t[7]=(h*u*r-l*a*r+l*e*o-s*u*o-h*e*x+s*a*x)*b,t[8]=p*b,t[9]=(m*c*r-l*y*r-m*i*x+s*y*x+l*i*_-s*c*_)*b,t[10]=(h*y*r-m*n*r+m*i*o-s*y*o-h*i*_+s*n*_)*b,t[11]=(l*n*r-h*c*r-l*i*o+s*c*o+h*i*x-s*n*x)*b,t[12]=g*b,t[13]=(l*y*e-m*c*e+m*i*u-s*y*u-l*i*z+s*c*z)*b,t[14]=(m*n*e-h*y*e-m*i*a+s*y*a+h*i*z-s*n*z)*b,t[15]=(h*c*e-l*n*e+l*i*a-s*c*a-h*i*u+s*n*u)*b,this}scale(t){const s=this.elements,i=t.x,e=t.y,r=t.z;return s[0]*=i,s[4]*=e,s[8]*=r,s[1]*=i,s[5]*=e,s[9]*=r,s[2]*=i,s[6]*=e,s[10]*=r,s[3]*=i,s[7]*=e,s[11]*=r,this}getMaxScaleOnAxis(){const t=this.elements,s=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],i=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],e=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(s,i,e))}makeTranslation(t,s,i){return this.set(1,0,0,t,0,1,0,s,0,0,1,i,0,0,0,1),this}makeRotationX(t){const s=Math.cos(t),i=Math.sin(t);return this.set(1,0,0,0,0,s,-i,0,0,i,s,0,0,0,0,1),this}makeRotationY(t){const s=Math.cos(t),i=Math.sin(t);return this.set(s,0,i,0,0,1,0,0,-i,0,s,0,0,0,0,1),this}makeRotationZ(t){const s=Math.cos(t),i=Math.sin(t);return this.set(s,-i,0,0,i,s,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,s){const i=Math.cos(s),e=Math.sin(s),r=1-i,h=t.x,n=t.y,a=t.z,o=r*h,l=r*n;return this.set(o*h+i,o*n-e*a,o*a+e*n,0,o*n+e*a,l*n+i,l*a-e*h,0,o*a-e*n,l*a+e*h,r*a*a+i,0,0,0,0,1),this}makeScale(t,s,i){return this.set(t,0,0,0,0,s,0,0,0,0,i,0,0,0,0,1),this}makeShear(t,s,i,e,r,h){return this.set(1,i,r,0,t,1,h,0,s,e,1,0,0,0,0,1),this}compose(t,s,i){const e=this.elements,r=s._x,h=s._y,n=s._z,a=s._w,o=r+r,l=h+h,c=n+n,u=r*o,x=r*l,m=r*c,y=h*l,z=h*c,_=n*c,M=a*o,d=a*l,p=a*c,g=i.x,f=i.y,b=i.z;return e[0]=(1-(y+_))*g,e[1]=(x+p)*g,e[2]=(m-d)*g,e[3]=0,e[4]=(x-p)*f,e[5]=(1-(u+_))*f,e[6]=(z+M)*f,e[7]=0,e[8]=(m+d)*b,e[9]=(z-M)*b,e[10]=(1-(u+y))*b,e[11]=0,e[12]=t.x,e[13]=t.y,e[14]=t.z,e[15]=1,this}decompose(t,s,i){const e=this.elements;let r=_v1$5.set(e[0],e[1],e[2]).length();const h=_v1$5.set(e[4],e[5],e[6]).length(),n=_v1$5.set(e[8],e[9],e[10]).length();this.determinant()<0&&(r=-r),t.x=e[12],t.y=e[13],t.z=e[14],_m1$2.copy(this);const a=1/r,o=1/h,l=1/n;return _m1$2.elements[0]*=a,_m1$2.elements[1]*=a,_m1$2.elements[2]*=a,_m1$2.elements[4]*=o,_m1$2.elements[5]*=o,_m1$2.elements[6]*=o,_m1$2.elements[8]*=l,_m1$2.elements[9]*=l,_m1$2.elements[10]*=l,s.setFromRotationMatrix(_m1$2),i.x=r,i.y=h,i.z=n,this}makePerspective(t,s,i,e,r,h){const n=this.elements,a=2*r/(s-t),o=2*r/(i-e),l=(s+t)/(s-t),c=(i+e)/(i-e),u=-(h+r)/(h-r),x=-2*h*r/(h-r);return n[0]=a,n[4]=0,n[8]=l,n[12]=0,n[1]=0,n[5]=o,n[9]=c,n[13]=0,n[2]=0,n[6]=0,n[10]=u,n[14]=x,n[3]=0,n[7]=0,n[11]=-1,n[15]=0,this}makeOrthographic(t,s,i,e,r,h){const n=this.elements,a=1/(s-t),o=1/(i-e),l=1/(h-r),c=(s+t)*a,u=(i+e)*o,x=(h+r)*l;return n[0]=2*a,n[4]=0,n[8]=0,n[12]=-c,n[1]=0,n[5]=2*o,n[9]=0,n[13]=-u,n[2]=0,n[6]=0,n[10]=-2*l,n[14]=-x,n[3]=0,n[7]=0,n[11]=0,n[15]=1,this}equals(t){const s=this.elements,i=t.elements;for(let t=0;t<16;t++)if(s[t]!==i[t])return!1;return!0}fromArray(t,s=0){for(let i=0;i<16;i++)this.elements[i]=t[i+s];return this}toArray(t=[],s=0){const i=this.elements;return t[s]=i[0],t[s+1]=i[1],t[s+2]=i[2],t[s+3]=i[3],t[s+4]=i[4],t[s+5]=i[5],t[s+6]=i[6],t[s+7]=i[7],t[s+8]=i[8],t[s+9]=i[9],t[s+10]=i[10],t[s+11]=i[11],t[s+12]=i[12],t[s+13]=i[13],t[s+14]=i[14],t[s+15]=i[15],t}}class Vector3{constructor(t=0,s=0,i=0){Vector3.prototype.isVector3=!0,this.x=t,this.y=s,this.z=i}set(t,s,i){return void 0===i&&(i=this.z),this.x=t,this.y=s,this.z=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,s){switch(t){case 0:this.x=s;break;case 1:this.y=s;break;case 2:this.z=s;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,s){return this.x=t.x+s.x,this.y=t.y+s.y,this.z=t.z+s.z,this}addScaledVector(t,s){return this.x+=t.x*s,this.y+=t.y*s,this.z+=t.z*s,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,s){return this.x=t.x-s.x,this.y=t.y-s.y,this.z=t.z-s.z,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,s){return this.x=t.x*s.x,this.y=t.y*s.y,this.z=t.z*s.z,this}applyEuler(t){return this.applyQuaternion(_quaternion$4.setFromEuler(t))}applyAxisAngle(t,s){return this.applyQuaternion(_quaternion$4.setFromAxisAngle(t,s))}applyMatrix3(t){const s=this.x,i=this.y,e=this.z,r=t.elements;return this.x=r[0]*s+r[3]*i+r[6]*e,this.y=r[1]*s+r[4]*i+r[7]*e,this.z=r[2]*s+r[5]*i+r[8]*e,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const s=this.x,i=this.y,e=this.z,r=t.elements,h=1/(r[3]*s+r[7]*i+r[11]*e+r[15]);return this.x=(r[0]*s+r[4]*i+r[8]*e+r[12])*h,this.y=(r[1]*s+r[5]*i+r[9]*e+r[13])*h,this.z=(r[2]*s+r[6]*i+r[10]*e+r[14])*h,this}applyQuaternion(t){const s=this.x,i=this.y,e=this.z,r=t.x,h=t.y,n=t.z,a=t.w,o=a*s+h*e-n*i,l=a*i+n*s-r*e,c=a*e+r*i-h*s,u=-r*s-h*i-n*e;return this.x=o*a+u*-r+l*-n-c*-h,this.y=l*a+u*-h+c*-r-o*-n,this.z=c*a+u*-n+o*-h-l*-r,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const s=this.x,i=this.y,e=this.z,r=t.elements;return this.x=r[0]*s+r[4]*i+r[8]*e,this.y=r[1]*s+r[5]*i+r[9]*e,this.z=r[2]*s+r[6]*i+r[10]*e,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,s){return this.x=Math.max(t.x,Math.min(s.x,this.x)),this.y=Math.max(t.y,Math.min(s.y,this.y)),this.z=Math.max(t.z,Math.min(s.z,this.z)),this}clampScalar(t,s){return this.x=Math.max(t,Math.min(s,this.x)),this.y=Math.max(t,Math.min(s,this.y)),this.z=Math.max(t,Math.min(s,this.z)),this}clampLength(t,s){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(s,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,s){return this.x+=(t.x-this.x)*s,this.y+=(t.y-this.y)*s,this.z+=(t.z-this.z)*s,this}lerpVectors(t,s,i){return this.x=t.x+(s.x-t.x)*i,this.y=t.y+(s.y-t.y)*i,this.z=t.z+(s.z-t.z)*i,this}cross(t){return this.crossVectors(this,t)}crossVectors(t,s){const i=t.x,e=t.y,r=t.z,h=s.x,n=s.y,a=s.z;return this.x=e*a-r*n,this.y=r*h-i*a,this.z=i*n-e*h,this}projectOnVector(t){const s=t.lengthSq();if(0===s)return this.set(0,0,0);const i=t.dot(this)/s;return this.copy(t).multiplyScalar(i)}projectOnPlane(t){return _vector$c.copy(this).projectOnVector(t),this.sub(_vector$c)}reflect(t){return this.sub(_vector$c.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const s=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===s)return Math.PI/2;const i=this.dot(t)/s;return Math.acos(clamp(i,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const s=this.x-t.x,i=this.y-t.y,e=this.z-t.z;return s*s+i*i+e*e}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,s,i){const e=Math.sin(s)*t;return this.x=e*Math.sin(i),this.y=Math.cos(s)*t,this.z=e*Math.cos(i),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,s,i){return this.x=t*Math.sin(s),this.y=i,this.z=t*Math.cos(s),this}setFromMatrixPosition(t){const s=t.elements;return this.x=s[12],this.y=s[13],this.z=s[14],this}setFromMatrixScale(t){const s=this.setFromMatrixColumn(t,0).length(),i=this.setFromMatrixColumn(t,1).length(),e=this.setFromMatrixColumn(t,2).length();return this.x=s,this.y=i,this.z=e,this}setFromMatrixColumn(t,s){return this.fromArray(t.elements,4*s)}setFromMatrix3Column(t,s){return this.fromArray(t.elements,3*s)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,s=0){return this.x=t[s],this.y=t[s+1],this.z=t[s+2],this}toArray(t=[],s=0){return t[s]=this.x,t[s+1]=this.y,t[s+2]=this.z,t}fromBufferAttribute(t,s){return this.x=t.getX(s),this.y=t.getY(s),this.z=t.getZ(s),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=2*(Math.random()-.5),s=Math.random()*Math.PI*2,i=Math.sqrt(1-t**2);return this.x=i*Math.cos(s),this.y=i*Math.sin(s),this.z=t,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const _matrix$1=new Matrix4,_zero=new Vector3(0,0,0),_one=new Vector3(1,1,1);class Euler{constructor(t=0,s=0,i=0,e=Euler.DefaultOrder){this.isEuler=!0,this._x=t,this._y=s,this._z=i,this._order=e}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,s,i,e=this._order){return this._x=t,this._y=s,this._z=i,this._order=e,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,s=this._order,i=!0){const e=t.elements,r=e[0],h=e[4],n=e[8],a=e[1],o=e[5],l=e[9],c=e[2],u=e[6],x=e[10];switch(s){case"XYZ":this._y=Math.asin(clamp(n,-1,1)),Math.abs(n)<.9999999?(this._x=Math.atan2(-l,x),this._z=Math.atan2(-h,r)):(this._x=Math.atan2(u,o),this._z=0);break;case"YXZ":this._x=Math.asin(-clamp(l,-1,1)),Math.abs(l)<.9999999?(this._y=Math.atan2(n,x),this._z=Math.atan2(a,o)):(this._y=Math.atan2(-c,r),this._z=0);break;case"ZXY":this._x=Math.asin(clamp(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(-c,x),this._z=Math.atan2(-h,o)):(this._y=0,this._z=Math.atan2(a,r));break;case"ZYX":this._y=Math.asin(-clamp(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(u,x),this._z=Math.atan2(a,r)):(this._x=0,this._z=Math.atan2(-h,o));break;case"YZX":this._z=Math.asin(clamp(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-l,o),this._y=Math.atan2(-c,r)):(this._x=0,this._y=Math.atan2(n,x));break;case"XZY":this._z=Math.asin(-clamp(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(u,o),this._y=Math.atan2(n,r)):(this._x=Math.atan2(-l,x),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+s)}return this._order=s,!0===i&&this._onChangeCallback(),this}setFromQuaternion(t,s,i){return _matrix$1.makeRotationFromQuaternion(t),this.setFromRotationMatrix(_matrix$1,s,i)}setFromVector3(t,s=this._order){return this.set(t.x,t.y,t.z,s)}reorder(t){return _quaternion$3.setFromEuler(this),this.setFromQuaternion(_quaternion$3,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],void 0!==t[3]&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],s=0){return t[s]=this._x,t[s+1]=this._y,t[s+2]=this._z,t[s+3]=this._order,t}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}toVector3(){console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")}}class EventDispatcher{addEventListener(t,s){void 0===this._listeners&&(this._listeners={});const i=this._listeners;void 0===i[t]&&(i[t]=[]),-1===i[t].indexOf(s)&&i[t].push(s)}hasEventListener(t,s){if(void 0===this._listeners)return!1;const i=this._listeners;return void 0!==i[t]&&-1!==i[t].indexOf(s)}removeEventListener(t,s){if(void 0===this._listeners)return;const i=this._listeners[t];if(void 0!==i){const t=i.indexOf(s);-1!==t&&i.splice(t,1)}}dispatchEvent(t){if(void 0===this._listeners)return;const s=this._listeners[t.type];if(void 0!==s){t.target=this;const i=s.slice(0);for(let s=0,e=i.length;s<e;s++)i[s].call(this,t);t.target=null}}}function clamp(t,s,i){return Math.max(s,Math.min(i,t))}export{Euler,EventDispatcher,Vector3};